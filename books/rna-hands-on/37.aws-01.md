---
title: "【4. AWSデプロイ編】全体の流れ"
---

## AWSデプロイの全体像

ここからは開発したアプリのAWSデプロイを行なっていきます！

AWSは非常に広大なサービスの集合体であり、それらを把握して使いこなせるようにするのはかなり骨が折れます。なのでまずは、手を動かす前に、今回のAWSデプロイの全体像をお伝えしようかと思います。

## 構成図

『はじめに』でも記載した今回の構成図を再掲します。

![](https://storage.googleapis.com/zenn-user-upload/07cdf560e895-20230831.png)

この構成図の仕組みについて順を追って説明をすることを通じて、今回利用するAWSサービスの概要を掴んでもらえたらと思っています。

### AWSクラウドとは?

改めてAWS(Amazon Web Service)とは、Amazonが提供する**クラウドコンピューティングサービス**です。

クラウド、というとやや捉え所のない概念に感じるかもしれませんが、要するに「**Amazonがたくさん持っているコンピューターの一部分をレンタルして何かしらに利用できるというサービス**」と思っていただければ大筋で問題はありません。

今回は、**開発したアプリをインターネット上からアクセスできる場所に公開すること**、を目的にこれを利用する、というイメージです。

![](https://storage.googleapis.com/zenn-user-upload/0dbc475789a6-20230906.png)

### VPC

さて、AWS上にアプリをデプロイするためには、まず広大なAWSクラウドという土地の中に「自分だけが利用できる土地」を確保する必要があります。

AWSクラウドは、あくまでもコンピューターの集合体です。自分以外の他の人もたくさん利用するものですので、「ここからここまでがウチのテリトリーだからね」というのを決めておかないと後々問題になってしまいます。

この「自分だけが利用できる土地」のことを、**VPC(Virtual Private Clound)** といいます。まずは、VPCを確保するところから全てが始まります。

![](https://storage.googleapis.com/zenn-user-upload/7b8a86b9bb38-20230906.png)

### サブネット

VPCを確保したら、それを目的に応じたいくつかの領域に分割します。VPCを分割した単位を**サブネット**といいます。

今回のケースでは、大きく分けると、**パブリックサブネット**と**プライベートサブネット**の2種類のサブネットにVPCを分割します。

パブリックサブネットは、インターネットクライアントとのデータのやり取りを行えるような環境を整備するサブネットで、アプリケーション本体などを配置します。

対してプライベートサブネットは、VPCの中でのみ利用できるサブネットで、例えばデータベースなどを配置します（データベースはアプリケーションから利用されるが、インターネットクライアントと直接やりとりは行わない）

![](https://storage.googleapis.com/zenn-user-upload/a78116574c55-20230906.png)

### ECS/ECR

**ECS(Elastic Container Service)** は、コンテナイメージ化されたアプリケーションをデプロイする場所です。ここが、アプリデプロイの本体部分といえます。

今回の開発においては、Dockerを用いてアプリの動作環境をコンテナ化して開発を進めてきました。こちらのコンテナの状態でAWS上にデプロイし、ローカルでコンテナを起動したのと同じような感覚で、AWS上で動かしてしまおう、というサービスです（実際は、本番環境用にコンテナ設定の修正は行います）。

**ECR(Elastic Container Resistory)** は、コンテナイメージをAWS上に保管して置く場所です。「ローカルでコンテナを作成してECRにプッシュし、それをECSで利用する」といった流れでデプロイを行なっていきます。

今回のアプリは、フロントエンドとして**Next.js**、バックエンドとして**Nginx+RailsAPI**の二つのECSを確保します。（「Nginxって何？なんで必要なの？」という疑問は該当の章で詳しく説明をしますが、「Railsを本番環境で安定して動作させるために必要なWebサーバー機能」ということだけ認識しておいてください）

いずれのECSも、**パブリックサブネット**内に配置し、インターネットからアクセスができる状態に設定していきます。

![](https://storage.googleapis.com/zenn-user-upload/ad2e5d77d8d5-20230906.png)

### RDS

**RDS(Relational Database Service)** は、AWSが提供するデータベースサービスです。今回はこれを利用して、MySQLサーバーを用意します。

RDSは、**プライベートサブネット**内に配置し、Railsからのみアクセスができる状態に設定していきます。

![](https://storage.googleapis.com/zenn-user-upload/a27e32dce633-20230906.png)

### Route53

**Route53**は、AWSが提供するDNS(Domain Name System)サービスで、要するに**独自ドメインを購入することができるサービス**です。

今回はRoute53で任意の独自ドメインを購入していただき、「フロントエンドECS」「バックエンドECS」それぞれに独自ドメインでアクセスできるようにします。

また、Route53で取得した独自ドメインをECSに付与するために、**ALB(Application Load Balancer)** を各ECSに設定します（ALBは本来はシステムの負荷分散を目的にした機能ですが、今回は独自ドメイン付与を目的に利用します）。

![](https://storage.googleapis.com/zenn-user-upload/a9482076e97a-20230906.png)

### ACM

**ACM()** とは、Route53で取得した独自ドメインにSSL認証をインストールするサービスです。要するに、**HTTPS**プロトコルによるセキュアなアプリアクセスを可能にしてくれます。

![](https://storage.googleapis.com/zenn-user-upload/f1d00035e2a4-20230906.png)

### CDパイプライン(GithubAction)

上記まででAWSサービスとしては完結していますが、付随するものとして、GithubActionによるCDパイプラインの構築を行います。

**CD(Continuous Delivery)** パイプラインとは、「アプリケーションを継続的にデプロイできる仕組み」のことです。

今回は「**githubのmainブランチにコード差分が発生したこと**」をトリガーとして、github上で以下の処理を自動的に実行させるようにします。

- コンテナイメージを再作成
- 再作成したコンテナイメージをECRに再プッシュ
- 新しいコンテナイメージに基づいてECSを再起動

CDパイプラインを構築することで、実質的にデプロイ作業を行う必要がなく、自動的に開発を本番環境に反映してくれるようになります。

![](https://storage.googleapis.com/zenn-user-upload/07cdf560e895-20230831.png)

## まずは「習うより慣れろ」の精神で

ここまでで、今回の構築するAWS環境の全体像を解説しました。

初見では「ふーん、そんなもんなんだ」くらいの感想かなと思うのですが、一通り手を動かしてみると理解できるようになっていると思います。どんどん先に進んでしまってください！
